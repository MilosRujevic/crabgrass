# = MailAccount
# An implementation of the FeedrAccount interface, capable of retrieving 
# messages from remote mailboxes. Currently only fetch methods for IMAP servers
# are implemented. MailAccount can (and by default will) use SSL to communicate
# with the mailbox.
#
# In order to implement a new fetch method (e.g. POP) do the following:
# * Define a module for your methods:
#     module MailAccount::POPFetchModule
# * define the following methods:
#   [receive(spec)] should return an Array of TMail::Mail objects. May only raise 
#                   FeedrAccount::FeedrFailure. receive may take an argument containing
#                   specifications for fetching.
#   [receive_recent( )] doesn't take arguments, should call receive with the
#                       appropriate arguments to fetch recent messages
#   [receive_all( )] same as receive_recent, but fetch all available messages instead
# 
# You can use your fetch method by passing :fetch => 'POP' to MailAccount.new
# This will automatically extend the newly created MailAccount with your module.
class MailAccount < FeedrAccount
  credentials :server, :login, :password, [:inbox, :port, :use_ssl]
  
  # normally a child class of ActionMailer::Base, however only the `deliver'
  # class method is used, so this class does not rely on ActionMailer. The 
  # ActionMailer needs to be configured appropriately beforehand 
  # (try ActionMailer::Base.smtp_settings).
  cattr_accessor :action_mailer
  
  # our default for the MailAccount
  action_mailer = ActionFeedr
  
  # FIXME: THIS IS CURRENTLY NOT WORKING AT ALL
  # additional options:
  # * :fetch - method used to receive messages. Currently only 'IMAP' is 
  #            supported, which therefore is the default (see above)
=begin
  def initialize args=nil
    if args && args.kind_of?(Hash)
      self.extend("#{args.delete(:fetch) || 'IMAP'}FetchMethods".constantize)
    end
    args ? super(args) : super()
  end
=end

  def send_message msg
    raise "Not Action Mailer" unless @@action_mailer
    @@action_mailer.deliver(msg)
  end

  module IMAPFetchMethods
    require 'net/imap'
    
    # Will either return the result of `receive!' or (in case of an error) raise
    # FeedrAccount::FeedrFailure with an appropriate message. This basically 
    # encapsulates any possible error generated by `receive!' into a
    # FeedrAccount::FeedrFailure object.
    # 
    # The original Exception is stored in
    # FeedrAccount::FeedrFailure#original_exception for further inspection.
    def receive receive_spec, options = {}
      msg = nil
      ret = nil
      x = nil
      begin
        ret = self.receive!(receive_spec, options)
        # generated by Net::IMAP.new
      rescue Errno::ECONNREFUSED => exc ; x = exc
        msg = 'Connection refused.'
      rescue Errno::ETIMEDOUT => exc ; x = exc
        msg = 'Connection timed out.'
      rescue Errno::ENETUNREACH => exc ; x = exc
        msg = 'Network unreachable / no route to host.'
      rescue SocketError => exc ; x = exc
        msg = 'SocketError: '+exc.message
      rescue Net::IMAP::NoResponseError
        case @_last_imap_state
        when :login : msg = "Authentication failed."
        when :select : msg = "Mailbox doesn't exist or non-selectable"  
        when :search : msg = 'search failed'
        when :fetch : msg = 'fetch failed'
        end
      rescue => exc ; x = exc
        msg = "#{exc.class}: #{exc.message}"
      end
      if msg
        error = FeedrFailure.new('Error while receiving messages from IMAP: '+
                                 msg)
        error.original_exception = x
        raise error
      end
      ret
    end

    # receives messages from IMAP server, based on the given receive_spec.
    # `receive_spec' may be any valid IMAP search command. (try 'RECENT' or 'ALL')
    # Authentication and settings are based upon the credentials field.
    # valid options are:
    # * :flag_deleted - if set to true, message is marked/flagged as 'Deleted'
    #   after it is fetch (Default: false)
    # * :expunge      - if set to true, a 'expunge' command is issued after all
    #   messages have been received. This cause previously marked
    #   'Deleted' messages to be permanently removed. (Default: true)
    #
    # On success, this method returns an Array of TMail::Mail objects.
    # During the whole process an arbitrary Exception may be raised. Use `receive'
    # to handle errors.
    def receive! receive_spec, options = {}
      # apply default settings for optional credentials/settings
      inbox = self.inbox || 'INBOX'
      use_ssl = self.use_ssl.nil? ? true : self.use_ssl
      port = self.port || (use_ssl ? 993 : 143)
      mails = []
      options = {
        :flag_deleted => false,
        :expunge => true,
        # TODO naybe we need more options/flags later?
      }.merge(options)
      imap = Net::IMAP.new(self.server, port, use_ssl)
      @_last_imap_state = :login
      imap.login(self.login, self.password)
      @_last_imap_state = :select
      imap.select(inbox)
      @_last_imap_state = :search
      imap.search([receive_spec]).each do |message_id|
        @_last_imap_state = :fetch
        mails << TMail::Mail.parse(imap.fetch(message_id,
                                              "RFC822")[0].attr['RFC822'])
        imap.store(message_id, "+FLAGS", [:Deleted]) if options[:flag_deleted]
        imap.expunge if options[:expunge]
      end
      imap.logout
      mails
    end
    
    # call `receive' with the appropriate parameters to return recent messages
    # only.
    def receive_recent
      receive 'RECENT'
    end
 
    # call `receive' with the appropriate parameters to reeturn all available
    # messages.
    def receive_all
      receive 'ALL'
    end
    
    # dummy to call an archive
    #
    def receive_archived
      receive_all
    end
    
  end

  # needed because our initializer (see above) doesn't work currently.
  include IMAPFetchMethods
  
end

=begin

class Protocol
  def connector
    # e.g. 
  end
  
  def can_ssl?
  end
  
  def required_credentials
    # e.g. [:login, :password] or [:ssh_privkey]
  end
end

class MailAccount < FeedrAccount
  def login= login
    self.credentials[:login] = login
  end
end

=end
